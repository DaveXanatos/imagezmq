"""pub_sub_receive.py -- Receive PiCamera image stream using PUB SUB.

This program (written for the Raspberry Pi but should be easily adaptable
to any Python/Linux platform) is designed to allow many independent scripts
to watch and act on the image stream generated by this script.  Examples
include Face and Object recognition, OCR, etc.

Initial testing and development had revealed an issue with a queue building
in the ZMQ SUB if the script was at all slower than the broadcasting node.
A temporary workaround was found by including the ImageHub instantiation
INSIDE the receiver-side (SUB) loop, rather than before it as would be normal.
While this is not an ideal solution, it is what works at the moment until such
time as developers allow greater control over the core ZMQ SUB Queue by
interpreted languages such as Python.

Additional functions were added in subsequent testing and development to
speed image transport over the network - namely, using OpenCV to reduce the
image dimensions before sending, as well as also applying JPG Compression.

Please note the import requirements, you may need to install several
dependencies such as numpy, and OpenCV, as well as ZMQ in order to
run this script successfully.

This script requires either a sym link to imagezmq, or that the
imagezmq folder must be present in project folder.

Brief test instructions are in the /docs/pub_sub_broadcast.rst file
"""

import sys
import time
import numpy as np
import cv2
import imagezmq

# Create a "Place Holder" image to feed to the initially blank window
test_img = np.zeros(shape=(300,400,3)).astype('uint8')
# Create and open a window to display the received image stream
# Note that in newer versions of OpenCV, the imshow() window may apply
# a banner above the image and an image data window below the image.
# This additional overhead can be removed using the WINDOW_GUI_NORMAL
# flag as shown here.  If you want the image data, simply leave this flag
# off of the code.
cv2.namedWindow('IMAGE', cv2.WINDOW_GUI_NORMAL)
cv2.imshow('IMAGE',test_img)
cv2.moveWindow('IMAGE',125,0) # 125,0 is Horizontal, vertical window position
cv2.waitKey(1)

while True:  # press Ctrl-C to stop image display program
    image_hub = imagezmq.ImageHub(open_port='tcp://192.168.1.210:5561', REQ_REP=False)
    image_name, jpg_buffer = image_hub.recv_jpg()
    image = cv2.imdecode(np.frombuffer(jpg_buffer, dtype='uint8'), -1)
    cv2.imshow('IMAGE', image)
    #cv2.waitKey(1)  # wait until a key is pressed
    key = cv2.waitKey(1) & 0xFF
    # if the `q` key was pressed, break from the loop
    if key == ord("q"):
        break

