"""pub_sub_broadcast.py -- Broadcast PiCamera image stream using PUB SUB.

This program (written for the Raspberry Pi but should be easily adaptable
to any Python/Linux platform) is designed to allow many independent scripts
to watch and act on the image stream generated by this script.  Examples
include Face and Object recognition, OCR, etc.

Initial testing and development had revealed an issue with a queue building
in the ZMQ SUB if the script was at all slower than the broadcasting node.
A temporary workaround was found by including the ImageHub instantiation
INSIDE the receive-side (SUB) loop, rather than before it as would be normal.
The broadcast side ImageHub remains before the loop.  While this is not
an ideal solution, it is what works at the moment until such time as ZMQ
developers allow greater control over the core ZMQ SUB Queue by interpreted
languages such as Python.

Additional functions were added in subsequent testing and development to
speed image transport over the network - namely, using OpenCV to reduce the
image dimensions before sending, as well as also applying JPG Compression.

Note that the default script here uses a delay of 0.1 seconds between cycles
to reduce frame rate to roughly 10 per second.  Depending on the speed of your
systems you may wish to adjust that sleep timer to meet your needs and
capabilities.

Please note the import requirements, you may need to install several
dependencies such as imutils, numpy, and OpenCV, as well as ZMQ in order to
run this script successfully.

This script requires either a sym link to imagezmq, or that the
imagezmq folder must be present in project folder.

Brief test instructions are in the /docs/pub_sub_broadcast.rst file
"""

import imutils
from imutils.video import VideoStream
import argparse
import socket
import sys
import time
import numpy as np
import cv2
import imagezmq

# Create an image sender in PUB/SUB (non-blocking) mode
sender = imagezmq.ImageSender(connect_to='tcp://192.168.1.210:5560', REQ_REP=False)

vs = VideoStream(src=0).start() #Also works with the Pi Camera
time.sleep(2.0)  # Settle in and sync up
jpeg_quality = 75  #Adjust if necessary.  75 seems good for Face Recognition

image_window_name = 'IMAGE' # Anything you like here
while True:  # press Ctrl-C to stop image sending program
    # Send an image to the queue
    frame = vs.read()
    frame = imutils.resize(frame, width=400) # Resize as needed.  
    ret_code, jpg_buffer = cv2.imencode(".jpg", frame, [int(cv2.IMWRITE_JPEG_QUALITY), jpeg_quality])
    sender.send_jpg(image_window_name, jpg_buffer)
    time.sleep(.1) # This sets it to ~ 10fps.  Increase or decrease as needed.


